# 软件设计-领域驱动设计（DDD）

## 背景来源

​		领域建模和设计的重要性在很早之前就被一些软件开发人员所发现 ，Eric Evans将其定义为领域驱动设计（Domain-Driven Design，简称DDD）。近些年来这种自顶而下的设计方式越发被推崇。作为开发者的我，也加入了学习的行列。



## 贫血模型vs充血模型

**贫血模型**：也称贫血领域对象，指仅用作数据载体，而没有行为和动作的领域对象。

**充血模型**：也称充血领域对象，同时定义数据和行为的领域对象。

个人理解：

贫血模型：提供基本的数据支持，不包含实际业务逻辑。

充血模型：提供数据支持，同时提供具体业务逻辑支持。



### C++举例说明

​		查找资料现在网上关于DDD的讲解大多为JavaWeb方向的，笔者是一个使用C++作为主要编程语言的开发。所以就从用C++的方式做分别介绍。

如：统计一个班级同学的信息，并计算平均年龄。

**贫血模型：**

```c++
class Group
{
public:
    Group(){}
    List<Student> getStudentList() {...}
	void setStudentList(List<Student> list) {...}
    
private:
    List<Student> m_oStudent;
};

class AverageService
{
public:
    double getStudentAverageAge(..) {...}
};
```

**充血模型：**

```c++
class Group
{
public:
    Group(){}
	double getStudentAverageAge() {...}
    
private:
    List<Student> m_oStudent;
};

class AverageService
{
public:
    double getStudentAverageAge(..) {...}
};
```

对比两者代码，容易发现：

1. 贫血模型的Service是复杂的包含大量逻辑；充血模型里Service的逻辑单薄，由Group提供业务实现。
2. 贫血模型的Group只是数据的存取，充血模型的Service里是包含业务逻辑的。



在这个基础上，对充血模型再做一点延伸。

在Group的基础上抽一层接口:

```c++
class IGroupInf
{
public:
    virtual double getAverageAge() {...}
}
class Group
{
public:
    Group(){}
	virtual double getAverageAge() {...}
    
private:
    List<Student> m_oStudent;
};

class AverageService
{
public:
    double getStudentAverageAge(..) {...}
};
```

容易的发现Group的业务变化不在会影响外层使用，业务的变化和外在的使用各自独立变化。

但是在贫血模型里，很难做到这一点；在贫血模型里，即便是抽了接口也无济于事，外在对数据是强依赖的；业务会分散到各个控制种去。



### 面向对象的角度

从OO的角度去审视贫血模型和充血模型，会发现：贫血模型的本质是在一堆数据上建立一个一个业务流程，并没有把数据和对应的行为做有机的整合，所以这个还是一个面向过程的实现方式。充血模型既有数据也有对应的行为，这是面向对象的。



### 如何选择

我们知道充血模型即要抽象属性，也要抽象行为；会比贫血模型更难设计。所以在选用时也有相应的偏好，或者有结合使用的情况。

 如果业务只是简单的CRUD，或者CRUD可以解决90%的业务情况。推荐使用贫血模型。其实大量的项目都是这样的简单项目。

但是如果在做复杂的项目，拥有复杂的业务时，我们就需要使用充血模型；



**DDD的思想就是充血模型的体现。** 



## 如何做DDD

领域驱动设计的重点是领域建模。

**工具：** 

​	UML工具，表格等



**步骤：** 

1. 搜集用户故事（用户的原始需求）
2. 整理用户故事，抽出用例（用例表达了用户对系统的需求，定义了系统的边界以及系统外部角色和系统的交互场景）
3. 分析系统需求，将领域拆分为多个子域（领域是问题空间，本质上就是大问题拆分为小问题）
4. 抽取每个子域的领域概念，得到概念模型（概念模型存在于问题空间）
5. 将子域的概念模型**抽象**并转化为领域模型（领域模型存在于解决方案空间，这一步是难点，考验抽象能力，如对关系的建模，如促销系统中抽象出促销产品，权限系统中抽象出授权）
6. 找出领域模型中的聚合，以及每个聚合的聚合根（聚合是一簇相互关联，聚会根是这一簇关系中不依赖别人，可以直接被访问的节点。）
7. 梳理聚合之间的关系
8. 场景走查，检查领域模型如何满足用例需求



**关键点：** 

1. 识别问题的复杂性（领域是为了解决复杂问题而存在的， 如果不能识别问题的复杂性，定义的领域将不能解决实际问题）
2. 抽象确定严格意义（限界上下文）
3. 统一语言（通用语言，统一知识积累）